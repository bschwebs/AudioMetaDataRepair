<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Metadata Repair Tool</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸŽµ Audio Metadata Repair Tool</h1>
            <p>Repair metadata, download album art, and generate NFO files for your music collection</p>
        </header>

        <main>
            <form id="processForm">
                <div class="form-group">
                    <label for="target_dir">Target Directory:</label>
                    <div class="directory-input-group">
                        <input type="text" id="target_dir" name="target_dir" 
                               placeholder="e.g., Z:\Audio\Music" required>
                        <button type="button" id="browseBtn" class="btn-browse">Browse</button>
                        <input type="file" id="directoryPicker" webkitdirectory directory multiple style="display: none;">
                    </div>
                    <small>Enter the full server-side path to your music directory. Click "Browse" to try directory selection (may require manual entry due to browser security).</small>
                </div>

                <div class="options-group">
                    <h3>Processing Options</h3>
                    
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" name="repair_metadata" checked>
                            <span>Repair Metadata</span>
                            <small>Update ID3 tags and Vorbis comments from filenames</small>
                        </label>
                    </div>

                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" name="download_art" checked>
                            <span>Download Album Art</span>
                            <small>Download and embed album covers from MusicBrainz</small>
                        </label>
                    </div>

                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" name="generate_nfo" checked>
                            <span>Generate NFO Files</span>
                            <small>Create album.nfo files for albums without one</small>
                        </label>
                    </div>
                </div>

                <button type="submit" id="submitBtn" class="btn-primary">Start Processing</button>
            </form>

            <div id="progressContainer" class="hidden">
                <h3>Processing...</h3>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <p id="progressText">Initializing...</p>
                <p id="currentFile" class="current-file"></p>
            </div>
        </main>

        <footer>
            <p>Audio Metadata Repair Tool - Flask Web Interface</p>
        </footer>
    </div>

    <script>
        const form = document.getElementById('processForm');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const currentFile = document.getElementById('currentFile');
        const submitBtn = document.getElementById('submitBtn');
        const browseBtn = document.getElementById('browseBtn');
        const directoryPicker = document.getElementById('directoryPicker');
        const targetDirInput = document.getElementById('target_dir');

        // Handle directory selection
        browseBtn.addEventListener('click', () => {
            directoryPicker.click();
        });

        directoryPicker.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                // Get the directory path from the first file
                const firstFile = e.target.files[0];
                let directoryPath = '';
                
                // Try to get the full path (works in some browsers)
                if (firstFile.path) {
                    // IE/Edge - we can get the full path
                    directoryPath = firstFile.path.substring(0, firstFile.path.lastIndexOf('\\'));
                    targetDirInput.value = directoryPath;
                    targetDirInput.removeAttribute('readonly');
                } else if (firstFile.webkitRelativePath) {
                    // Chrome/Edge - we only get relative path
                    // Extract directory from relative path
                    const relativePath = firstFile.webkitRelativePath;
                    const parts = relativePath.split('/');
                    if (parts.length > 1) {
                        parts.pop(); // Remove filename
                        const relativeDir = parts.join('/');
                        
                        // Show info message
                        const message = 'Browser security prevents accessing the full path.\n\n' +
                                      'Please enter the full server-side path manually.\n\n' +
                                      'Relative path: ' + relativeDir;
                        alert(message);
                        
                        // Make input editable for manual entry
                        targetDirInput.removeAttribute('readonly');
                        targetDirInput.placeholder = 'Enter full server path (e.g., Z:\\Audio\\Music)';
                        targetDirInput.focus();
                    }
                } else {
                    // Fallback - make input editable
                    targetDirInput.removeAttribute('readonly');
                    targetDirInput.placeholder = 'Enter full server path (e.g., Z:\\Audio\\Music)';
                    targetDirInput.focus();
                }
            }
        });

        // Make input editable on focus if it's readonly (for manual entry)
        targetDirInput.addEventListener('focus', () => {
            if (targetDirInput.hasAttribute('readonly')) {
                targetDirInput.removeAttribute('readonly');
            }
        });

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const formData = {
                target_dir: document.getElementById('target_dir').value,
                repair_metadata: document.querySelector('input[name="repair_metadata"]').checked,
                download_art: document.querySelector('input[name="download_art"]').checked,
                generate_nfo: document.querySelector('input[name="generate_nfo"]').checked
            };

            submitBtn.disabled = true;
            submitBtn.textContent = 'Starting...';
            form.classList.add('hidden');
            progressContainer.classList.remove('hidden');

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();
                
                if (data.error) {
                    alert('Error: ' + data.error);
                    resetForm();
                    return;
                }

                const sessionId = data.session_id;
                pollStatus(sessionId);

            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred: ' + error.message);
                resetForm();
            }
        });

        function pollStatus(sessionId) {
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/status/${sessionId}`);
                    const data = await response.json();

                    if (data.status === 'error') {
                        clearInterval(interval);
                        alert('Error: ' + data.message);
                        resetForm();
                        return;
                    }

                    if (data.status === 'processing') {
                        progressFill.style.width = data.progress + '%';
                        progressText.textContent = `Progress: ${data.progress}%`;
                        if (data.current_file) {
                            currentFile.textContent = `Processing: ${data.current_file}`;
                        }
                    }

                    if (data.status === 'completed') {
                        clearInterval(interval);
                        progressFill.style.width = '100%';
                        progressText.textContent = 'Processing complete!';
                        currentFile.textContent = '';
                        
                        // Redirect to results page
                        setTimeout(() => {
                            window.location.href = `/results/${sessionId}`;
                        }, 1000);
                    }

                } catch (error) {
                    console.error('Error polling status:', error);
                    clearInterval(interval);
                    alert('Error checking status: ' + error.message);
                    resetForm();
                }
            }, 1000);
        }

        function resetForm() {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Start Processing';
            form.classList.remove('hidden');
            progressContainer.classList.add('hidden');
            progressFill.style.width = '0%';
        }
    </script>
</body>
</html>

